(()=>{var W=globalThis.fetch,f=globalThis.WebSocket,U=globalThis.Request,S=globalThis.Response,m=globalThis.SharedWorker,T=globalThis.localStorage,v=globalThis.navigator.serviceWorker,g={prototype:{send:f.prototype.send},CLOSED:f.CLOSED,CLOSING:f.CLOSING,CONNECTING:f.CONNECTING,OPEN:f.OPEN};async function k(){let e=(await self.clients.matchAll({type:"window",includeUncontrolled:!0})).map(async r=>{let n=await F(r);return await R(n),n}),s=Promise.race([Promise.any(e),new Promise((r,n)=>setTimeout(n,1e3,new TypeError("timeout")))]);try{return await s}catch(r){if(r instanceof AggregateError)throw console.error("bare-mux: failed to get a bare-mux SharedWorker MessagePort as all clients returned an invalid MessagePort."),new Error("All clients returned an invalid MessagePort.");return console.warn("bare-mux: failed to get a bare-mux SharedWorker MessagePort within 1s, retrying"),await k()}}function F(c){let e=new MessageChannel;return new Promise(s=>{c.postMessage({type:"getPort",port:e.port2},[e.port2]),e.port1.onmessage=r=>{s(r.data)}})}function R(c){let e=new MessageChannel,s=new Promise((r,n)=>{e.port1.onmessage=i=>{i.data.type==="pong"&&r()},setTimeout(n,1500)});return c.postMessage({message:{type:"ping"},port:e.port2},[e.port2]),s}function P(c,e){let s=new m(c,"bare-mux-worker");return e&&v.addEventListener("message",r=>{if(r.data.type==="getPort"&&r.data.port){console.debug("bare-mux: recieved request for port from sw");let n=new m(c,"bare-mux-worker");r.data.port.postMessage(n.port,[n.port])}}),s.port}var M=class{constructor(e){this.channel=new BroadcastChannel("bare-mux"),e instanceof MessagePort?this.port=e:this.createChannel(e,!0)}createChannel(e,s){if(self.clients)this.port=k(),this.channel.onmessage=r=>{r.data.type==="refreshPort"&&(this.port=k())};else if(e&&m){if(!e.startsWith("/")&&!e.includes("://"))throw new Error("Invalid URL. Must be absolute or start at the root.");this.port=P(e,s),console.debug("bare-mux: setting localStorage bare-mux-path to",e),T["bare-mux-path"]=e}else if(m){let r=T["bare-mux-path"];if(console.debug("bare-mux: got localStorage bare-mux-path:",r),!r)throw new Error("Unable to get bare-mux workerPath from localStorage.");this.port=P(r,s)}else throw new Error("Unable to get a channel to the SharedWorker.")}async sendMessage(e,s){this.port instanceof Promise&&(this.port=await this.port);try{await R(this.port)}catch{return console.warn("bare-mux: Failed to get a ping response from the worker within 1.5s. Assuming port is dead."),this.createChannel(),await this.sendMessage(e,s)}let r=new MessageChannel,n=[r.port2,...s||[]],i=new Promise((p,o)=>{r.port1.onmessage=l=>{let a=l.data;a.type==="error"?o(a.error):p(a)}});return this.port.postMessage({message:e,port:r.port2},n),await i}};var A="!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";function I(c){for(let e=0;e<c.length;e++){let s=c[e];if(!A.includes(s))return!1}return!0}var G=["ws:","wss:"],j=[101,204,205,304],D=[301,302,303,307,308];var E=class{constructor(e){this.worker=new M(e)}createWebSocket(e,s=[],r,n,i){try{e=new URL(e)}catch{throw new DOMException(`Faiiled to construct 'WebSocket': The URL '${e}' is invalid.`)}if(!G.includes(e.protocol))throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${e.protocol}' is not allowed.`);Array.isArray(s)||(s=[s]),s=s.map(String);for(let t of s)if(!I(t))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${t}' is invalid.`);let p=r||f,o=new p("ws://127.0.0.1:1",s),l="",a=g.CONNECTING,h=!1;o.addEventListener("error",t=>{h||(a=f.CONNECTING,t.stopImmediatePropagation(),h=!0)});let b=!1;o.addEventListener("close",t=>{b||(t.stopImmediatePropagation(),b=!0)}),i=i||p.constructor.constructor("return ArrayBuffer")().prototype,n=n||{},n.Host=new URL(e).host,n.Pragma="no-cache",n["Cache-Control"]="no-cache",n.Upgrade="websocket",n.Connection="Upgrade";let y=t=>{a=g.OPEN,l=t,o.meta={headers:{"sec-websocket-protocol":t}},o.dispatchEvent(new Event("open"))},x=async t=>{typeof t=="string"?o.dispatchEvent(new MessageEvent("message",{data:t})):"byteLength"in t?(o.binaryType==="blob"?t=new Blob([t]):Object.setPrototypeOf(t,i),o.dispatchEvent(new MessageEvent("message",{data:t}))):"arrayBuffer"in t&&(o.binaryType==="arraybuffer"&&(t=await t.arrayBuffer(),Object.setPrototypeOf(t,i)),o.dispatchEvent(new MessageEvent("message",{data:t})))},O=(t,d)=>{a=g.CLOSED,o.dispatchEvent(new CloseEvent("close",{code:t,reason:d}))},N=()=>{a=g.CLOSED,o.dispatchEvent(new Event("error"))},w=new MessageChannel;w.port1.onmessage=t=>{t.data.type==="open"?y(t.data.args[0]):t.data.type==="message"?x(t.data.args[0]):t.data.type==="close"?O(t.data.args[0],t.data.args[1]):t.data.type==="error"&&N()},this.worker.sendMessage({type:"websocket",websocket:{url:e.toString(),origin,protocols:s,requestHeaders:n,channel:w.port2}},[w.port2]);let C=()=>a;Object.defineProperty(o,"readyState",{get:C,configurable:!0,enumerable:!0});let L=()=>{if(C()===g.CONNECTING)return new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.")};return o.send=function(...t){let d=L();if(d)throw d;let u=t[0];u.buffer&&(u=u.buffer),w.port1.postMessage({type:"data",data:u},u instanceof ArrayBuffer?[u]:[])},o.close=function(t,d){w.port1.postMessage({type:"close",closeCode:t,closeReason:d})},Object.defineProperty(o,"url",{get:()=>e.toString(),configurable:!0,enumerable:!0}),Object.defineProperty(o,"protocol",{get:()=>l,configurable:!0,enumerable:!0}),o}async fetch(e,s){let r=new U(e,s),n=s?.headers||r.headers,i=n instanceof Headers?Object.fromEntries(n):n,p=r.body,o=new URL(r.url);if(o.protocol.startsWith("blob:")){let l=await W(o),a=new S(l.body,l);return a.rawHeaders=Object.fromEntries(l.headers),a.rawResponse=l,a}for(let l=0;;l++){"host"in i?i.host=o.host:i.Host=o.host;let a=(await this.worker.sendMessage({type:"fetch",fetch:{remote:o.toString(),method:r.method,headers:i,body:p||void 0}},p?[p]:[])).fetch,h=new S(j.includes(a.status)?void 0:a.body,{headers:new Headers(a.headers),status:a.status,statusText:a.statusText});h.rawHeaders=a.headers,h.rawResponse=new S(a.body),h.finalURL=o.toString();let b=s?.redirect||r.redirect;if(D.includes(h.status))switch(b){case"follow":{let y=h.headers.get("location");if(20>l&&y!==null){o=new URL(y,o);continue}else throw new TypeError("Failed to fetch")}case"error":throw new TypeError("Failed to fetch");case"manual":return h}else return h}}};self.SkyhighServiceWorker=class{constructor(){this.client=new E,this.prefix="/sh/"}route({request:e}){return!!e.url.startsWith(location.origin+this.prefix)}async fetch(e){let s=new URL(e.request.url),r=decodeURIComponent(s.pathname.replace(this.prefix,""));try{return await this.client.fetch(r)}catch(n){return console.error("Fetch failed:",n),new Response("Error fetching the URL",{status:500})}}};})();
